<!doctype html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ES80</title>
    <link rel="stylesheet" href="../style.css" />
  </head>
  <body>
    <div id="main">
    	<h1>M√£o na massa: Chain of Responsibility</h1>
      <h2>Problema:</h2>

      <p>
        Uma aplica√ß√£o de e-commerce precisa se comunicar com v√°rios bancos diferentes para prover aos seus usu√°rios mais possibilidades de pagamentos, atingindo assim um n√∫mero maior de usu√°rios e facilitando suas vidas.<br><br>

        Ao modelar uma forma de execu√ß√£o do pagamento, dado que precisamos selecionar um entre v√°rios tipos de bancos, a primeira ideia que surge √© utilizar uma estrutura de decis√£o para verificar, dado um par√¢metro, qual o banco correto deve ser utilizado.<br><br>

        j√° discutimos no post sobre o padr√£o Strategy que utilizar uma estrutura de decis√£o pode ser muito complexo, e vimos uma boa solu√ß√£o para este problema. Tamb√©m vimos exemplos de utiliza√ß√£o de estruturas de decis√£o nos padr√µs Abstract Factory e Factory Method.<br><br>

        Poder√≠amos utilizar os m√©todos f√°bricas para gerar o objeto correto para ser utilizado na nossa aplica√ß√£o. Poder√≠amos criar estrat√©gias diferentes para cada banco e escolher em tempo de execu√ß√£o.<br><br>

        Em todas estas solu√ß√µes, n√≥s utilizamos uma forma de ‚Äúesconder‚Äù a estrutura de decis√£o por tr√°s de uma interface, ou algo similar, para que as altera√ß√µes fossem menos dolorosas. No entanto, continuamos utilizando as estruturas de decis√£o.<br><br>

        Vamos analisar ent√£o o padr√£o Chain of Responsibility, que promete acabar com estas estruturas.<br><br>
      </p>

      <h2>Chain of Responsibility</h2>
      <p>
        O padr√£o Chain of Responsibility possui a seguinte inten√ß√£o:<br><br>

        ‚ÄúEvitar o acoplamento do remetente de uma solicita√ß√£o ao seu receptor, ao dar a mais de um objeto a oportunidade de tratar a solicita√ß√£o. Encadear os objetos receptores, passando a solicita√ß√£o ao longo da cadeia at√© que um objeto a trate.‚Äù [1]<br><br>

        Pela inten√ß√£o percebemos como o Chain of Responsibility acaba com as estruturas de decis√£o, ele cria uma cadeia de objetos e vai passando a responsabilidade entre eles at√© que algu√©m possa responder pela chamada.<br><br>

        Vamos ent√£o iniciar construindo uma pequena enumera√ß√£o para identificar os bancos utilizados no nosso sistema:<br><br>
      </p>
        
      <pre>
        1     <span>public enum</span> IDBancos {
        2         bancoA, bancoB, bancoC, bancoD
        3     }
      </pre>
      <br><br>
      Agora vamos construir a classe que vai implementar a cadeia de responsabilidades. Vamos exibir partes do c√≥digo para facilitar o entendimento.
      <br><br>
      <pre>
        1   <span>public abstract class</span> BancoChain {
        2
        3       <span>protected</span> BancoChain next;
        4       <span>protected</span> IDBancos identificadorDoBanco;
        5
        6       <span>public</span> BancoChain(IDBancos id) {
        7                 next = <span>null</span>;
        8                 identificadorDoBanco = id;
        9            }
        10
        11     <span>public void</span> setNext(BancoChain forma) {
        12           <span>if</span> (next == <span>null</span>) {
        13                    next = forma;
        14                 } <span>else</span> {
        15                    next.setNext(forma);
        16                 }
        17          }
        18  }
      </pre>

      A nossa classe possui apenas dois atributos, o identificador do banco e uma refer√™ncia para o pr√≥ximo objeto da corrente. No construtor inicializamos estes atributos. O m√©todo setNext recebe uma nova inst√¢ncia da classe e faz o seguinte:<br><br>

      Se o pr√≥ximo for nulo, ent√£o o pr√≥ximo na corrente ser√° o par√¢metro. Caso contr√°rio, repassa esta responsabilidade para o pr√≥ximo elemento. Assim, a inst√¢ncia que deve ser adicionada na corrente ir√° percorrer os elementos at√© chegar no √∫ltimo elemento.<br><br>

      O pr√≥ximo passo ser√° criar o m√©todo para efetuar o pagamento.<br><br>

      <pre>
        1   <span>public void</span> efetuarPagamento(IDBancos id) <span>throws</span> Exception {
        2
        3       if (podeEfetuarPagamento(id)) {
        4         efetuaPagamento();
        5       } <span>else</span> {
        6           <span>if</span> (next == <span>null</span>) {
        7                 <span>throw new</span>  Exception("banco n√£o cadastrado");
        8                 identificadorDoBanco = id;
        9                 }
        10                next.efetuarPagamento(id);
        11            }
        12      }
        13      <span>private boolean</span> podeEfetuarPagamento(IDBancos id) {
        14               <span>if </span> (identificadorDoBanco == id){
        15                        <span>return true;</span>
        16                 }
        17                  return false;
        18            }
        19      <span>protected abstract void</span> efetuaPagamento();
      </pre>
      A primeira parte do algoritmo de pagamento √© verificar se o banco atual pode fazer o pagamento. Para isto √© utilizado o identificador do banco, que √© comparado com o identificador passado por par√¢metro. Se o elemento atual puder responder a requisi√ß√£o √© chamado o m√©todo que vai efetuar o pagamento de fato. Este m√©todo √© abstrato, e as subclasses devem implement√°-lo, com seu pr√≥prio mecanismo.<br><br>

      Se o elemento atual n√£o puder responder, ele repassa a chamado ao pr√≥ximo elemento da lista. Antes disto √© feita uma verifica√ß√£o, por quest√µes de seguran√ßa, se este pr√≥ximo elemento realmente existe. Caso nenhum elemento possa responder, √© disparada uma exce√ß√£o.<br><br>

      Agora que definimos a estrutura da cadeia de responsabilidades, vamos implementar um banco concreto, que responde a uma chamada.<br><br>

      <pre>
          1    <span>public class</span>  BancoA <span>extends</span> BancoChain {
          2
          3     <span>public</span> BancoA() {
          4        <span>super</span>(IDBancos.bancoA);
          5     }
          6 
          7     @Override
          8     <span>protected void</span> efetuaPagamento() {
          9        System.out.println("Pagamento efetuado no banco A");
          10    }
          11   }
      </pre>
      O Banco A inicializa seu ID e, no m√©todo de efetuar o pagamento, exibe no terminal que o pagamento foi efetuado. A implementa√ß√£o dos outros bancos segue este exemplo. O ID √© iniciado e o m√©todo de efetuar o pagamento exibe a sa√≠da no terminal.<br><br>

      O cliente deste c√≥digo seria algo do tipo:<br><br>
      <pre>
        1  <span>public static void</span> main(String[] args) {
        2           BancoChain bancos = <span>new</span> BancoA();
        3           bancos.setNext(<span>new</span> BancoB());
        4           bancos.setNext(<span>new</span> BancoC());
        5           bancos.setNext(<span>new</span> BancoD());
        6       
        7      <span>try</span> {
        8               bancos.efetuarPagamento(IDBancos.bancoC);
        9               bancos.efetuarPagamento(IDBancos.bancoD);
        10              bancos.efetuarPagamento(IDBancos.bancoA);
        11              bancos.efetuarPagamento(IDBancos.bancoB);
        12     } <span>catch</span> (Exception e) {
        13              e.printStackTrace();
        14     }
        15  }
      </pre>
      <br><br>
      O diagrama UML deste exemplo seria:
      <div class="img">
        <img src="https://brizeno.wordpress.com/wp-content/uploads/2011/11/chain.png" width="80%" >
      </div>
        
      <h2>Um pouco de teoria</h2>
      <p>
        Vimos pelo exemplo que o padr√£o Chain of Responsibility fornece uma maneira de tomar decis√µes com um fraco acoplamento. Perceba que a estrutura de cadeia n√£o possui qualquer informa√ß√£o sobre as classes que comp√µem a cadeia, da mesma forma, uma classe da cadeia n√£o tem nenhuma no√ß√£o sobre o formato da estrutura ou sobre elementos nela inseridos.<br><br>

        Assim, √© poss√≠vel variar praticamente todos os componentes sem grandes danos ao projeto. Cada elemento implementa sua pr√≥pria maneira de responder a requisi√ß√£o, e estas podem ser alteradas facilmente.<br><br>

        O problema √© que √© preciso tomar cuidado para garantir que as chamadas sejam realmente respondidas. No exemplo foi feita uma verifica√ß√£o para saber se o pr√≥ximo elemento √© nulo, para evitar uma acesso ilegal. Mas esta √© uma solu√ß√£o para este problema espec√≠fico. Cada problema exige o seu pr√≥prio cuidado.<br><br>

        <h3>C√≥digo fonte completo</h3>
        O c√≥digo completo pode ser baixado no seguinte reposit√≥rio Git: https://github.com/MarcosX/Padr-es-de-Projeto.<br><br>

        Os arquivos est√£o como um projeto do eclipse, ent√£o basta colocar no seu Workspace e fazer o import.<br><br>

        Se gostou do post compartilhe com seus amigos e colegas, sen√£o, comente o que pode ser melhorado. Encontrou algum erro no c√≥digo? Comente tamb√©m. Possui alguma outra opini√£o ou alguma informa√ß√£o adicional? Comenta ai! üòÄ</p>

      <h3>
      <a href="https://brizeno.wordpress.com/2011/11/09/mao-na-massa-chain-of-responsibility/" target="_blank">Fonte</a>
      </h3>
    </div>
  </body>
</html>
